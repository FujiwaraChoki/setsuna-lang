---
title: Control Flow
description: Conditionals and control flow in Setsuna
---

# Control Flow

Setsuna provides expressive control flow constructs that are all expressions, meaning they return values.

## If Expressions

The `if` expression evaluates a condition and returns one of two values:

```typescript
let x = 10
let result = if x > 5 { "big" } else { "small" }
print(result)  // "big"
```

### Basic Syntax

```typescript
if condition {
    // then branch
} else {
    // else branch
}
```

### Else-If Chains

```typescript
fn grade(score) {
    if score >= 90 {
        "A"
    } else if score >= 80 {
        "B"
    } else if score >= 70 {
        "C"
    } else if score >= 60 {
        "D"
    } else {
        "F"
    }
}

print(grade(85))  // "B"
print(grade(72))  // "C"
```

<Note>
Since `if` is an expression, both branches must return compatible types.
</Note>

### Without Else

If you omit the `else` branch, the expression returns `()` (unit) when the condition is false:

```typescript
let x = 10
if x > 20 {
    print("x is big")
}
// Returns () if condition is false
```

## Loop Expressions

Setsuna provides `while` and `for` loops for iteration. Like all control flow in Setsuna, loops are expressions that return values.

### While Loops

The `while` loop repeatedly executes a block while a condition is true:

```typescript
let x = 0
while x < 5 {
    print(x)
    x = x + 1
}
// Prints: 0, 1, 2, 3, 4
```

The loop returns the last value of the body, or `()` if the condition is initially false:

```typescript
let result = {
    let count = 0
    while count < 3 {
        count = count + 1
        count * 10
    }
}
print(result)  // 30 (last iteration's value)
```

### For Loops

The `for` loop iterates over elements in a list:

```typescript
for x in [1, 2, 3, 4, 5] {
    print(x * x)
}
// Prints: 1, 4, 9, 16, 25
```

Use `range` to iterate over a range of numbers:

```typescript
for i in range(0, 5) {
    print(f"Index: {i}")
}
// Prints: Index: 0, Index: 1, ... Index: 4
```

### Loop Patterns

**Accumulating Results:**

```typescript
let sum = {
    let total = 0
    for n in [1, 2, 3, 4, 5] {
        total = total + n
    }
    total
}
print(sum)  // 15
```

**Processing Collections:**

```typescript
let names = ["Alice", "Bob", "Charlie"]
for name in names {
    print(f"Hello, {name}!")
}
```

<Note>
While loops are useful for imperative-style iteration, consider using higher-order functions like `map`, `filter`, and `fold` for more idiomatic functional programming.
</Note>

## Match Expressions

Pattern matching is the preferred way to handle multiple cases:

```typescript
fn describe(n) {
    match n {
        0 => "zero",
        1 => "one",
        2 => "two",
        _ => "many"
    }
}

print(describe(0))  // "zero"
print(describe(5))  // "many"
```

See [Pattern Matching](/advanced/pattern-matching) for comprehensive coverage.

## Blocks as Expressions

Blocks `{ ... }` are expressions that return their last value:

```typescript
let result = {
    let a = 10
    let b = 20
    a + b  // This value is returned
}
print(result)  // 30
```

### Nested Blocks

```typescript
let value = {
    let x = {
        let inner = 5
        inner * 2
    }
    x + 10
}
print(value)  // 20
```

## Boolean Operators

### Short-Circuit Evaluation

`&&` and `||` use short-circuit evaluation:

```typescript
// && stops if first is false
let result = false && expensive_function()  // expensive_function not called

// || stops if first is true
let result = true || expensive_function()   // expensive_function not called
```

### Logical Operations

```typescript
let a = true
let b = false

print(a && b)   // false
print(a || b)   // true
print(!a)       // false
print(!b)       // true
```

## Comparison Operators

| Operator | Description |
|----------|-------------|
| `==` | Equal |
| `!=` | Not equal |
| `<` | Less than |
| `>` | Greater than |
| `<=` | Less than or equal |
| `>=` | Greater than or equal |

```typescript
print(5 == 5)   // true
print(5 != 3)   // true
print(3 < 5)    // true
print(5 > 3)    // true
print(3 <= 3)   // true
print(5 >= 5)   // true
```

## Common Patterns

### Guard Clauses

Use early returns via pattern matching:

```typescript
fn process(value) {
    match value {
        0 => "cannot process zero",
        n if n < 0 => "cannot process negative",
        n => "processing: " + str(n)
    }
}
```

### Conditional Assignment

```typescript
let status = if is_valid { "ok" } else { "error" }

let message = match code {
    200 => "Success",
    404 => "Not Found",
    500 => "Server Error",
    _ => "Unknown"
}
```

### Recursive Conditionals

```typescript
fn find_first_positive(lst) {
    match lst {
        [] => None,
        [h, ...t] => if h > 0 {
            Some(h)
        } else {
            find_first_positive(t)
        }
    }
}
```

## Everything is an Expression

In Setsuna, there are no statementsâ€”everything is an expression that produces a value:

```typescript
// if is an expression
let a = if true { 1 } else { 2 }

// match is an expression
let b = match a {
    1 => "one",
    _ => "other"
}

// blocks are expressions
let c = {
    let x = 10
    let y = 20
    x + y
}

// function body is an expression
fn get_value() => if true { 42 } else { 0 }
```

## Next Steps

<Cards>
  <Card title="Pattern Matching" href="/advanced/pattern-matching" />
  <Card title="Functions" href="/basics/functions" />
</Cards>
