---
title: Language Grammar
description: Formal grammar specification for Setsuna
---

# Language Grammar

This page provides a formal specification of Setsuna's grammar in Extended Backus-Naur Form (EBNF).

## Notation

| Symbol | Meaning |
|--------|---------|
| `::=` | Definition |
| `\|` | Alternative |
| `[ ]` | Optional (0 or 1) |
| `{ }` | Repetition (0 or more) |
| `( )` | Grouping |
| `"x"` | Terminal symbol |
| `'x'` | Terminal character |

## Program Structure

```text
program         ::= { declaration }

declaration     ::= let_binding
                  | function_def
                  | type_def
                  | module_def
                  | import_decl
                  | expression

import_decl     ::= "import" identifier [ "as" identifier ]

let_binding     ::= "let" pattern "=" expression

function_def    ::= "fn" identifier "(" [ param_list ] ")" function_body

function_body   ::= "=>" expression
                  | block

param_list      ::= identifier { "," identifier }

type_def        ::= "type" identifier "{" constructor_list "}"

constructor_list ::= constructor { "," constructor }

constructor     ::= identifier [ "(" param_list ")" ]

module_def      ::= "module" identifier "{" { declaration } "}"
```

## Expressions

```text
expression      ::= if_expr
                  | match_expr
                  | while_expr
                  | for_expr
                  | lambda_expr
                  | binary_expr

if_expr         ::= "if" expression block [ "else" ( if_expr | block ) ]

while_expr      ::= "while" expression block

for_expr        ::= "for" identifier "in" expression block

match_expr      ::= "match" expression "{" match_arms "}"

match_arms      ::= match_arm { "," match_arm } [ "," ]

match_arm       ::= pattern [ "if" expression ] "=>" expression

lambda_expr     ::= "(" [ param_list ] ")" "=>" expression

binary_expr     ::= unary_expr { binary_op unary_expr }

unary_expr      ::= [ unary_op ] postfix_expr

postfix_expr    ::= primary_expr { postfix_op }

postfix_op      ::= "(" [ arg_list ] ")"    (* function call *)
                  | "." identifier           (* field access *)
                  | "." integer              (* tuple index *)

primary_expr    ::= literal
                  | identifier
                  | module_access
                  | "(" expression ")"
                  | "[" [ expr_list ] "]"
                  | "(" expression "," expr_list ")"  (* tuple *)
                  | "{" [ field_list ] "}"            (* record *)
                  | "%{" [ map_entries ] "}"          (* map *)
                  | block

module_access   ::= identifier "::" identifier

map_entries     ::= map_entry { "," map_entry }

map_entry       ::= expression ":" expression

block           ::= "{" { statement } expression "}"

statement       ::= let_binding
                  | expression
```

## Patterns

```text
pattern         ::= literal_pattern
                  | identifier_pattern
                  | wildcard_pattern
                  | list_pattern
                  | tuple_pattern
                  | record_pattern
                  | constructor_pattern

literal_pattern ::= integer | float | string | "true" | "false"

identifier_pattern ::= identifier

wildcard_pattern ::= "_"

list_pattern    ::= "[" [ pattern_list [ "," "..." identifier ] ] "]"

tuple_pattern   ::= "(" pattern "," pattern_list ")"

record_pattern  ::= "{" field_pattern_list "}"

field_pattern_list ::= field_pattern { "," field_pattern }

field_pattern   ::= identifier ":" pattern

constructor_pattern ::= identifier [ "(" pattern_list ")" ]

pattern_list    ::= pattern { "," pattern }
```

## Operators

```text
binary_op       ::= "+" | "-" | "*" | "/" | "%"
                  | "==" | "!=" | "<" | ">" | "<=" | ">="
                  | "&&" | "||"

unary_op        ::= "-" | "!"
```

## Literals

```text
literal         ::= integer
                  | float
                  | string
                  | fstring
                  | boolean

integer         ::= [ "-" ] digit { digit }

float           ::= [ "-" ] digit { digit } "." digit { digit }

string          ::= '"' { string_char } '"'

fstring         ::= 'f"' { fstring_part } '"'

fstring_part    ::= fstring_char
                  | "{" expression "}"

fstring_char    ::= <any character except '"', '\', and '{'>
                  | escape_seq

string_char     ::= <any character except '"' and '\'>
                  | escape_seq

escape_seq      ::= "\\" | '\"' | "\n" | "\t" | "\r" | "\{" | "\}"

boolean         ::= "true" | "false"

identifier      ::= letter { letter | digit | "_" }

letter          ::= 'a'..'z' | 'A'..'Z'

digit           ::= '0'..'9'
```

## Lists and Records

```text
expr_list       ::= expression { "," expression }

arg_list        ::= expression { "," expression }

field_list      ::= field { "," field }

field           ::= identifier ":" expression
```

## Lexical Elements

### Keywords

```
let     fn      if      else    match
type    module  import  as      true
false   while   for     in
```

### Reserved for Future Use

```
export  trait   impl    where
async   await   mut     ref     pub
```

### Comments

```text
line_comment    ::= "//" { <any character except newline> }
```

## Examples

### Let Binding

```typescript
let x = 5
let name = "Alice"
let (a, b) = (1, 2)
let [h, ...t] = [1, 2, 3]
```

**Grammar derivation:**
```
let_binding → "let" pattern "=" expression
            → "let" identifier "=" literal
            → "let" "x" "=" "5"
```

### Function Definition

```typescript
fn add(x, y) => x + y

fn factorial(n) {
    match n {
        0 => 1,
        _ => n * factorial(n - 1)
    }
}
```

**Grammar derivation:**
```
function_def → "fn" identifier "(" param_list ")" function_body
             → "fn" "add" "(" "x" "," "y" ")" "=>" binary_expr
             → "fn" "add" "(" "x" "," "y" ")" "=>" "x" "+" "y"
```

### Type Definition

```typescript
type Option {
    Some(value),
    None
}

type Tree {
    Leaf(value),
    Node(left, right)
}
```

**Grammar derivation:**
```
type_def → "type" identifier "{" constructor_list "}"
         → "type" "Option" "{" constructor "," constructor "}"
         → "type" "Option" "{" "Some" "(" "value" ")" "," "None" "}"
```

### Match Expression

```typescript
match value {
    0 => "zero",
    n if n > 0 => "positive",
    _ => "negative"
}
```

**Grammar derivation:**
```
match_expr → "match" expression "{" match_arms "}"
           → "match" "value" "{" match_arm "," match_arm "," match_arm "}"
```

### Lambda Expression

```typescript
let double = (x) => x * 2
let add = (a, b) => a + b
let constant = () => 42
```

**Grammar derivation:**
```
lambda_expr → "(" param_list ")" "=>" expression
            → "(" "x" ")" "=>" binary_expr
            → "(" "x" ")" "=>" "x" "*" "2"
```

### Loop Expressions

```typescript
// While loop
let x = 0
while x < 5 {
    print(x)
    x = x + 1
}

// For loop
for item in [1, 2, 3] {
    print(item)
}
```

**Grammar derivation:**
```
while_expr → "while" expression block
           → "while" "x" "<" "5" block

for_expr → "for" identifier "in" expression block
         → "for" "item" "in" "[" "1" "," "2" "," "3" "]" block
```

### Import Declaration

```typescript
import MathUtils
import MathUtils as M
```

**Grammar derivation:**
```
import_decl → "import" identifier
            → "import" "MathUtils"

import_decl → "import" identifier "as" identifier
            → "import" "MathUtils" "as" "M"
```

### Module Access

```typescript
let result = MathUtils::square(5)
let pi = M::PI
```

**Grammar derivation:**
```
module_access → identifier "::" identifier
              → "MathUtils" "::" "square"
```

### Map Literal

```typescript
let empty = %{ }
let config = %{ "name": "Alice", "age": 30 }
```

**Grammar derivation:**
```
primary_expr → "%{" map_entries "}"
             → "%{" map_entry "," map_entry "}"
             → "%{" "\"name\"" ":" "\"Alice\"" "," "\"age\"" ":" "30" "}"
```

### F-String (Interpolated String)

```typescript
let name = "Alice"
let greeting = f"Hello, {name}!"
let math = f"2 + 2 = {2 + 2}"
```

**Grammar derivation:**
```
fstring → 'f"' fstring_part fstring_part fstring_part '"'
        → 'f"' "Hello, " "{" identifier "}" "!" '"'
        → 'f"' "Hello, " "{" "name" "}" "!" '"'
```

## Precedence and Associativity

### Expression Precedence (Highest to Lowest)

1. **Primary**: Literals, identifiers, parenthesized expressions
2. **Postfix**: Function calls (`.`), field access (`.`)
3. **Unary**: `-`, `!`
4. **Multiplicative**: `*`, `/`, `%`
5. **Additive**: `+`, `-`
6. **Relational**: `<`, `>`, `<=`, `>=`
7. **Equality**: `==`, `!=`
8. **Logical AND**: `&&`
9. **Logical OR**: `||`

### Associativity

- **Left-associative**: `+`, `-`, `*`, `/`, `%`, comparisons, `&&`, `||`
- **Right-associative**: `=>`

## Whitespace and Formatting

- Whitespace is generally ignored except as token separator
- Newlines can appear within blocks and expressions
- Indentation is not significant (not like Python)

```typescript
// These are equivalent:
let x = if true { 1 } else { 2 }

let x = if true {
    1
} else {
    2
}

let x = if true
{
    1
}
else
{
    2
}
```

## Next Steps

<Cards>
  <Card title="Built-in Functions" href="/reference/builtins" />
  <Card title="Quick Start" href="/quickstart" />
</Cards>
